{"meta":{"title":"Zongyunの博客","subtitle":"没看出我哪里变了吗？","description":"没看出我哪里变了吗？","author":"zongyun","url":"https://zongyun1999.github.io","root":"/"},"pages":[{"title":"Music","date":"2020-05-22T14:22:27.000Z","updated":"2020-05-25T10:05:44.947Z","comments":true,"path":"Music/index.html","permalink":"https://zongyun1999.github.io/Music/index.html","excerpt":"","text":""},{"title":"About","date":"2021-03-11T14:44:00.012Z","updated":"2021-03-11T14:44:00.012Z","comments":true,"path":"about/index.html","permalink":"https://zongyun1999.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-03-11T14:44:00.018Z","updated":"2021-03-11T14:44:00.018Z","comments":true,"path":"tags/index.html","permalink":"https://zongyun1999.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2021-03-11T14:44:00.013Z","updated":"2021-03-11T14:44:00.013Z","comments":true,"path":"categories/index.html","permalink":"https://zongyun1999.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Tomcat&Servlet笔记","date":"2020-09-06T14:17:09.578Z","updated":"2021-03-11T13:49:14.995Z","comments":true,"path":"2020/09/06/Tomcat&Servlet笔记/","link":"","permalink":"https://zongyun1999.github.io/2020/09/06/Tomcat&Servlet%E7%AC%94%E8%AE%B0/","excerpt":"web相关概念回顾 web服务器软件：Tomcat Servlet入门学习","text":"web相关概念回顾 web服务器软件：Tomcat Servlet入门学习 web相关概念回顾 软件架构 C/S：客户端/服务器端 B/S：浏览器/服务器端 资源分类 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析 如： html,css,JavaScript 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器 如：servlet/jsp,php,asp…. 网络通信三要素 IP：电子设备(计算机)在网络中的唯一标识。 端口：应用程序在计算机中的唯一标识。 0~65536 传输协议：规定了数据传输的规则 基础协议： tcp:安全协议，三次握手。 速度稍慢 udp：不安全协议。 速度快 web服务器软件： 服务器：安装了服务器软件的计算机 服务器软件：接收用户的请求，处理请求，做出响应 web服务器软件：接收用户的请求，处理请求，做出响应。 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 web容器 常见的java相关的web服务器软件： webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Tomcat：web服务器软件 下载：http://tomcat.apache.org/ 安装：解压压缩包即可。 注意：安装目录建议不要有中文和空格 卸载：删除目录就行了 启动： bin/startup.bat ,双击运行该文件即可 访问：浏览器输入：http://localhost:8080 回车访问自己 http://别人的ip:8080 访问别人 可能遇到的问题： 黑窗口一闪而过： 原因： 没有正确配置JAVA_HOME环境变量 解决方案：正确配置JAVA_HOME环境变量 启动报错： 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 netstat -ano 温柔：修改自身的端口号 conf/server.xml 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 好处：在访问时，就不用输入端口号 关闭： 正常关闭： bin/shutdown.bat ctrl+c 强制关闭： 点击启动窗口的× 配置: 部署项目的方式： 直接将项目放到webapps目录下即可。 /hello：项目的访问路径–&gt;虚拟目录 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 war包会自动解压缩 配置conf/server.xml文件 在标签体中配置 * docBase:项目存放的路径 * path：虚拟目录 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写 * 虚拟目录：xml文件的名称 静态项目和动态项目： 目录结构 java动态项目的目录结构： – 项目的根目录-- WEB-INF目录： -- web.xml：web项目的核心配置文件 -- classes目录：放置字节码文件的目录 -- lib目录：放置依赖的jar包 ​ * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。 Servlet： server applet 概念：运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 将来我们自定义一个类，实现Servlet接口，复写方法。 快速入门： 创建JavaEE项目 定义一个类，实现Servlet接口 public class ServletDemo1 implements Servlet 实现接口中的抽象方法 配置Servlet 在web.xml中配置： 12345678910 &lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 执行原理： 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的标签体内容。 如果有，则在找到对应的全类名 tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 Servlet中的生命周期方法： 被创建：执行init方法，只执行一次 Servlet什么时候被创建？ 默认情况下，第一次被访问时，Servlet被创建 可以配置执行Servlet的创建时机。 在标签下配置 第一次被访问时，创建 的值为负数 在服务器启动时，创建 的值为0或正整数 Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 多个用户同时访问时，可能存在线程安全问题。 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 提供服务：执行service方法，执行多次 每次访问Servlet时，Service方法都会被调用一次。 被销毁：执行destroy方法，只执行一次 Servlet被销毁时执行。服务器关闭时，Servlet被销毁 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 Servlet3.0： 好处： 支持注解配置。可以不需要web.xml了。 步骤： 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口 复写方法 在类上使用@WebServlet注解，进行配置 @WebServlet(“资源路径”) 123456789101112131415161718192021222324@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebServlet &#123; String name() default \"\";//相当于&lt;Servlet-name&gt; String[] value() default &#123;&#125;;//代表urlPatterns()属性配置 String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default &#123;&#125;; boolean asyncSupported() default false; String smallIcon() default \"\"; String largeIcon() default \"\"; String description() default \"\"; String displayName() default \"\";&#125; IDEA与tomcat的相关配置 IDEA会为每一个tomcat部署的项目单独建立一份配置文件 查看控制台的log：Using CATALINA_BASE: “C:\\Users\\fqy.IntelliJIdea2018.1\\system\\tomcat_itcast” 工作空间项目 和 tomcat部署的web项目 tomcat真正访问的是“tomcat部署的web项目”，”tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源 WEB-INF目录下的资源不能被浏览器直接访问。 断点调试：使用”小虫子”启动 dubug 启动","categories":[],"tags":[]},{"title":"","slug":"Servlet&HTTP&Request笔记","date":"2020-09-06T14:17:09.576Z","updated":"2020-09-06T11:11:30.779Z","comments":true,"path":"2020/09/06/Servlet&HTTP&Request笔记/","link":"","permalink":"https://zongyun1999.github.io/2020/09/06/Servlet&HTTP&Request%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今日内容：1. Servlet 2. HTTP协议 3. RequestServlet：1. 概念 2. 步骤 3. 执行原理 4. 生命周期 5. Servlet3.0 注解配置 6. Servlet的体系结构 Servlet -- 接口 | GenericServlet -- 抽象类 | HttpServlet -- 抽象类 * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 * HttpServlet：对http协议的一种封装，简化操作 1. 定义类继承HttpServlet 2. 复写doGet/doPost方法 7. Servlet相关配置 1. urlpartten:Servlet访问路径 1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;}) 2. 路径定义规则： 1. /xxx：路径匹配 2. /xxx/xxx:多层路径，目录结构 3. *.do：扩展名匹配HTTP：* 概念：Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP/IP的高级协议 2. 默认端口号:80 3. 基于请求/响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接 * 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan * 响应消息数据格式Request：1. request对象和response对象的原理 1. request和response对象是由服务器创建的。我们来使用它们 2. request对象是来获取请求消息，response对象是来设置响应消息 2. request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) 3. request功能： 1. 获取请求消息数据 1. 获取请求行数据 * GET /day14/demo1?name=zhangsan HTTP/1.1 * 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/day14 * String getContextPath() 3. 获取Servlet路径: /demo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/demo1 * StringBuffer getRequestURL() :http://localhost/day14/demo1 * URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 * URI：统一资源标识符 : /day14/demo1 共和国 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() 2. 获取请求头数据 * 方法： * (*)String getHeader(String name):通过请求头的名称获取请求头的值 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 3. 获取请求体数据: * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 * 步骤： 1. 获取流对象 * BufferedReader getReader()：获取字符输入流，只能操作字符数据 * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 * 在文件上传知识点后讲解 2. 再从流对象中拿数据​​ 2. 其他功能：​ 1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数​ 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123​ 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game​ 3. Enumeration getParameterNames():获取所有请求的参数名称​ 4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合​ * 中文乱码问题： * get方式：tomcat 8 已经将get方式乱码问题解决了 * post方式：会乱码 * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(“utf-8”); ​​ 2. 请求转发：一种在服务器内部的资源跳转方式​ 1. 步骤：​ 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)​ 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)​ 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 3. 共享数据： * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 4. 获取ServletContext： * ServletContext getServletContext()案例：用户登录* 用户登录案例需求： 1.编写login.html登录页面 username &amp; password 两个输入框 2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表 3.使用JdbcTemplate技术封装JDBC 4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 * 分析 * 开发步骤 1. 创建项目，导入html页面，配置文件，jar包 2. 创建数据库环境 CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 3. 创建包cn.itcast.domain,创建类User package cn.itcast.domain; /** * 用户的实体类 */ public class User { private int id; private String username; private String password;​​ public int getId() {​ return id;​ }​ public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, username=&apos;&quot; + username + &apos;\\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\\&apos;&apos; + &apos;}&apos;; } } 4. 创建包cn.itcast.util,编写工具类JDBCUtils package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import javax.xml.crypto.Data; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC工具类 使用Durid连接池 */ public class JDBCUtils { private static DataSource ds ; static { try { //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; }​​ /**​ * 获取连接Connection对象​ */​ public static Connection getConnection() throws SQLException {​ return ds.getConnection();​ }​ }​ 5. 创建包cn.itcast.dao,创建类UserDao,提供login方法​ package cn.itcast.dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao { //声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser){ try { //1.编写sql String sql = &quot;select * from user where username = ? and password = ?&quot;; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword());​​ return user;​ } catch (DataAccessException e) {​ e.printStackTrace();//记录日志​ return null;​ }​ }​ }​ 6. 编写cn.itcast.web.servlet.LoginServlet类 package cn.itcast.web.servlet; import cn.itcast.dao.UserDao; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException;​​ @WebServlet(“/loginServlet”)​ public class LoginServlet extends HttpServlet { ​​ @Override​ protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {​ //1.设置编码​ req.setCharacterEncoding(“utf-8”);​ //2.获取请求参数​ String username = req.getParameter(“username”);​ String password = req.getParameter(“password”);​ //3.封装user对象​ User loginUser = new User();​ loginUser.setUsername(username);​ loginUser.setPassword(password);​ //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp); }else{ //登录成功 //存储数据 req.setAttribute(&quot;user&quot;,user); //转发 req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 7. 编写FailServlet和SuccessServlet类 @WebServlet(&quot;/successServlet&quot;) public class SuccessServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User) request.getAttribute(&quot;user&quot;); if(user != null){ //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;); }​​ } @WebServlet(&quot;/failServlet&quot;) public class FailServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 8. login.html中form表单的action路径的写法 * 虚拟目录+Servlet的资源路径 9. BeanUtils工具类，简化数据封装 * 用于封装JavaBean的 1. JavaBean：标准的Java类 1. 要求： 1. 类必须被public修饰 2. 必须提供空参的构造器 3. 成员变量必须使用private修饰 4. 提供公共setter和getter方法 2. 功能：封装数据 2. 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() --&gt; Username--&gt; username 3. 方法： 1. setProperty() 2. getProperty() 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中","categories":[],"tags":[]},{"title":"","slug":"JDBC连接池&JDBCTemplate课堂笔记","date":"2020-09-06T14:17:09.574Z","updated":"2020-09-06T08:34:06.818Z","comments":true,"path":"2020/09/06/JDBC连接池&JDBCTemplate课堂笔记/","link":"","permalink":"https://zongyun1999.github.io/2020/09/06/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0&JDBCTemplate%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/","excerpt":"","text":"大纲1. 数据库连接池 2. Spring JDBC : JDBC Template数据库连接池数据库连接池基本概念 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处： 节约资源 用户访问高效 实现： 标准接口：DataSource javax.sql包下的 方法： 获取连接：getConnection() 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 一般我们不去实现它，有数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供的 C3P0数据库连接池 C3P0：数据库连接池技术 步骤： 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， 不要忘记导入数据库驱动jar包 定义配置文件： 名称： c3p0.properties 或者 c3p0-config.xml 路径：直接将文件放在src目录下即可。 创建核心对象 数据库连接池对象 ComboPooledDataSource 获取连接： getConnection 代码： //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); Druid：数据库连接池 Druid：数据库连接池实现技术，由阿里巴巴提供的 步骤： 导入jar包 druid-1.0.9.jar 定义配置文件： 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 获取连接：getConnection 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(“druid.properties”); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 public class JDBCUtils &#123; //1.定义成员变量 DataSource private static DataSource ds ; static&#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement stmt,Connection conn)&#123; /* if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;*/ close(null,stmt,conn); &#125; public static void close(ResultSet rs , Statement stmt, Connection conn)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; Spring JDBC基本概念12345678910111213141516171819202122232425262728* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource * JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 * update():执行DML语句。增、删、改语句 * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 * 注意：这个方法查询的结果集长度只能是1 * queryForList():查询结果将结果集封装为list集合 * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 * query():查询结果，将结果封装为JavaBean对象 * query的参数：RowMapper * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 * new BeanPropertyRowMapper&lt;类型&gt;(类型.class) * queryForObject：查询结果，将结果封装为对象 * 一般用于聚合函数的查询 4. 练习： * 需求： 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数 代码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145* 代码： import cn.itcast.domain.Emp; import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; public class JdbcTemplateDemo2 &#123; //Junit单元测试，可以让方法独立执行 //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1()&#123; //2. 定义sql String sql = \"update emp set salary = 10000 where id = 1001\"; //3. 执行sql int count = template.update(sql); System.out.println(count); &#125; /** * 2. 添加一条记录 */ @Test public void test2()&#123; String sql = \"insert into emp(id,ename,dept_id) values(?,?,?)\"; int count = template.update(sql, 1015, \"郭靖\", 10); System.out.println(count); &#125; /** * 3.删除刚才添加的记录 */ @Test public void test3()&#123; String sql = \"delete from emp where id = ?\"; int count = template.update(sql, 1015); System.out.println(count); &#125; /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4()&#123; String sql = \"select * from emp where id = ? or id = ?\"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125; &#125; /** * 5. 查询所有记录，将其封装为List */ @Test public void test5()&#123; String sql = \"select * from emp\"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6()&#123; String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt(\"id\"); String ename = rs.getString(\"ename\"); int job_id = rs.getInt(\"job_id\"); int mgr = rs.getInt(\"mgr\"); Date joindate = rs.getDate(\"joindate\"); double salary = rs.getDouble(\"salary\"); double bonus = rs.getDouble(\"bonus\"); int dept_id = rs.getInt(\"dept_id\"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2()&#123; String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 7. 查询总记录数 */ @Test public void test7()&#123; String sql = \"select count(id) from emp\"; Long total = template.queryForObject(sql, Long.class); System.out.println(total); &#125; &#125; ​ ​ ​ 1","categories":[],"tags":[]},{"title":"","slug":"Java线程和同步","date":"2020-09-06T14:17:09.572Z","updated":"2020-09-06T08:34:09.696Z","comments":true,"path":"2020/09/06/Java线程和同步/","link":"","permalink":"https://zongyun1999.github.io/2020/09/06/Java%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%90%8C%E6%AD%A5/","excerpt":"","text":"Java线程和同步[TOC] 创建线程的2种方法通过继承线程类123456public class CreatThreadDemo2 extends Thread&#123; @Override public void run() &#123; System.out.println(\"第一种方式创建线程\"); &#125;&#125; 通过实现Runable接口12345678910111213Thread p = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"通过接口创建线程\"); &#125; &#125;); p.start(); Thread p2= new Thread(()-&gt;System.out.println(\"通过lamdal创建线程\")); p.start(); 线程安全：同步代码块、静态方法、锁12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ticketDemo implements Runnable&#123; private static int ticket=100; //Object obj=new Object();//作为锁 Lock lock= new ReentrantLock(); @Override public void run() &#123; while (true)&#123; payTicket3(); &#125; &#125; /* 使用同步方法 */ public void payTicket1() &#123; try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (ticketDemo.class)&#123; if (ticket&gt;0)&#123; ticket--; System.out.println(Thread.currentThread().getName()+\" \"+ticket+\" is sailing\"); &#125; &#125; &#125;/*使用静态代码块 */ public static synchronized void payTicket()&#123; //synchronized (ticketDemo.class)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (ticket&gt;0)&#123; ticket--; System.out.println(Thread.currentThread().getName()+\" \"+ticket+\" is sailing\"); &#125; &#125; public void payTicket3() &#123;//使用加锁的机制 try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // synchronized (ticketDemo.class)&#123; lock.lock(); if (ticket&gt;0)&#123; ticket--; System.out.println(Thread.currentThread().getName()+\" \"+ticket+\" is sailing\"); &#125; lock.unlock(); &#125; // &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"JavaScript基础笔记","date":"2020-09-06T14:17:09.570Z","updated":"2020-09-06T08:34:07.950Z","comments":true,"path":"2020/09/06/JavaScript基础笔记/","link":"","permalink":"https://zongyun1999.github.io/2020/09/06/JavaScript%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今日内容1. JavaScript基础JavaScript：* 概念： 一门客户端脚本语言 * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 * 脚本语言：不需要编译，直接就可以被浏览器解析执行了 * 功能： * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。 * JavaScript发展史： 1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C-- ，后来更名为：ScriptEase 2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 3. 1996年，微软抄袭JavaScript开发出JScript语言 4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM) * ECMAScript：客户端脚本语言的标准 1. 基本语法： 1. 与html结合方式 1. 内部JS： * 定义&lt;script&gt;，标签体内容就是js代码 2. 外部JS： * 定义&lt;script&gt;，通过src属性引入外部的js文件 * 注意： 1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。 2. &lt;script&gt;可以定义多个。 2. 注释 1. 单行注释：//注释内容 2. 多行注释：/*注释内容*/ 3. 数据类型： 1. 原始数据类型(基本数据类型)： 1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型) 2. string：字符串。 字符串 &quot;abc&quot; &quot;a&quot; &apos;abc&apos; 3. boolean: true和false 4. null：一个对象为空的占位符 5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined 2. 引用数据类型：对象 4. 变量 * 变量：一小块存储数据的内存空间 * Java语言是强类型语言，而JavaScript是弱类型语言。 * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 * 语法： * var 变量名 = 初始化值; * typeof运算符：获取变量的类型。 * 注：null运算后得到的是object 5. 运算符 1. 一元运算符：只有一个运算数的运算符 ++，-- ， +(正号) * ++ --: 自增(自减) * ++(--) 在前，先自增(自减)，再运算 * ++(--) 在后，先运算，再自增(自减) * +(-)：正负号 * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换 * 其他类型转number： * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字） * boolean转number：true转为1，false转为0 2. 算数运算符 + - * / % ... 3. 赋值运算符 = += -+.... 4. 比较运算符 &gt; &lt; &gt;= &lt;= == ===(全等于) * 比较方式 1. 类型相同：直接比较 * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。 2. 类型不同：先进行类型转换，再比较 * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false 5. 逻辑运算符 &amp;&amp; || ! * 其他类型转boolean： 1. number：0或NaN为假，其他为真 2. string：除了空字符串(&quot;&quot;)，其他都是true 3. null&amp;undefined:都是false 4. 对象：所有对象都为true 6. 三元运算符 ? : 表达式 var a = 3; var b = 4; var c = a &gt; b ? 1:0; * 语法： * 表达式? 值1:值2; * 判断表达式的值，如果是true则取值1，如果是false则取值2； 6. 流程控制语句： 1. if...else... 2. switch: * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7) * switch(变量): case 值: * 在JS中,switch语句可以接受任意的原始数据类型 3. while 4. do...while 5. for 7. JS特殊语法： 1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议) 2. 变量的定义使用var关键字，也可以不使用 * 用： 定义的变量是局部变量 * 不用：定义的变量是全局变量(不建议)​​ ​​ 2. 基本对象： 1. Function：函数(方法)对象 1. 创建： 1. var fun = new Function(形式参数列表,方法体); //忘掉吧 2. function 方法名称(形式参数列表){ 方法体 } 3. var 方法名 = function(形式参数列表){ 方法体 } 2. 方法： 3. 属性： length:代表形参的个数 4. 特点： 1. 方法定义是，形参的类型不用写,返回值类型也不写。 2. 方法是一个对象，如果定义名称相同的方法，会覆盖 3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关 4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数 5. 调用： 方法名称(实际参数列表); 2. Array:数组对象 1. 创建： 1. var arr = new Array(元素列表); 2. var arr = new Array(默认长度); 3. var arr = [元素列表]; 2. 方法 join(参数):将数组中的元素按照指定的分隔符拼接为字符串 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 3. 属性 length:数组的长度 4. 特点： 1. JS中，数组元素的类型可变的。 2. JS中，数组长度可变的。 3. Boolean 4. Date：日期对象 1. 创建： var date = new Date(); 2. 方法： toLocaleString()：返回当前date对象对应的时间本地字符串格式 getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 5. Math：数学对象 1. 创建： * 特点：Math对象不用创建，直接使用。 Math.方法名(); 2. 方法： random():返回 0 ~ 1 之间的随机数。 含0不含1 ceil(x)：对数进行上舍入。 floor(x)：对数进行下舍入。 round(x)：把数四舍五入为最接近的整数。 3. 属性： PI 6. Number 7. String 8. RegExp：正则表达式对象 1. 正则表达式：定义字符串的组成规则。 1. 单个字符:[] 如： [a] [ab] [a-zA-Z0-9_] * 特殊符号代表特殊含义的单个字符: \\d:单个数字字符 [0-9] \\w:单个单词字符[a-zA-Z0-9_] 2. 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n * m如果缺省： {,n}:最多n次 * n如果缺省：{m,} 最少m次 3. 开始结束符号 * ^:开始 * $:结束 2. 正则对象： 1. 创建 1. var reg = new RegExp(&quot;正则表达式&quot;); 2. var reg = /正则表达式/; 2. 方法 1. test(参数):验证指定的字符串是否符合正则定义的规范 9. Global 1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。 方法名(); 2. 方法： encodeURI():url编码 decodeURI():url解码 encodeURIComponent():url编码,编码的字符更多 decodeURIComponent():url解码 parseInt():将字符串转为数字 * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number isNaN():判断一个值是否是NaN * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。 3. URL编码 传智播客 = %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2 * BOM * DOM​","categories":[],"tags":[]},{"title":"","slug":"JavaScript高级笔记","date":"2020-09-06T14:17:09.568Z","updated":"2020-09-06T08:34:08.899Z","comments":true,"path":"2020/09/06/JavaScript高级笔记/","link":"","permalink":"https://zongyun1999.github.io/2020/09/06/JavaScript%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/","excerpt":"","text":"内容：1. JavaScript： 1. ECMAScript： 2. BOM： 3. DOM： 1. 事件DOM简单学习：为了满足案例要求* 功能：控制html文档的内容 * 获取页面标签(元素)对象：Element * document.getElementById(&quot;id值&quot;):通过元素的id获取元素对象 * 操作Element对象： 1. 修改属性值： 1. 明确获取的对象是哪一个？ 2. 查看API文档，找其中有哪些属性可以设置 2. 修改标签体内容： * 属性：innerHTML 1. 获取元素对象 2. 使用innerHTML属性修改标签体内容事件简单学习* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。 * 造句： xxx被xxx,我就xxx * 我方水晶被摧毁后，我就责备对友。 * 敌方水晶被摧毁后，我就夸奖自己。 * 如何绑定事件 1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码 1. 事件：onclick--- 单击事件 2. 通过js获取元素对象，指定事件属性，设置一个函数​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 * 代码： &lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\" onclick=\"fun();\"&gt; &lt;img id=\"light2\" src=\"img/off.gif\"&gt; &lt;script&gt; function fun()&#123; alert('我被点了'); alert('我又被点了'); &#125; function fun2()&#123; alert('咋老点我？'); &#125; //1.获取light2对象 var light2 = document.getElementById(\"light2\"); //2.绑定事件 light2.onclick = fun2; &lt;/script&gt; &lt;/body&gt;* 案例1：电灯开关 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;电灯开关&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\"&gt; &lt;script&gt; /* 分析： 1.获取图片对象 2.绑定单击事件 3.每次点击切换图片 * 规则： * 如果灯是开的 on,切换图片为 off * 如果灯是关的 off,切换图片为 on * 使用标记flag来完成 */ //1.获取图片对象 var light = document.getElementById(\"light\"); var flag = false;//代表灯是灭的。 off图片 //2.绑定单击事件 light.onclick = function()&#123; if(flag)&#123;//判断如果灯是开的，则灭掉 light.src = \"img/off.gif\"; flag = false; &#125;else&#123; //如果灯是灭的，则打开 light.src = \"img/on.gif\"; flag = true; &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ​ BOM:1. 概念：Browser Object Model 浏览器对象模型 * 将浏览器的各个组成部分封装成对象。 2. 组成： * Window：窗口对象 * Navigator：浏览器对象 * Screen：显示器屏幕对象 * History：历史记录对象 * Location：地址栏对象 3. Window：窗口对象 1. 创建 2. 方法 1. 与弹出框有关的方法： alert() 显示带有一段消息和一个确认按钮的警告框。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 * 如果用户点击确定按钮，则方法返回true * 如果用户点击取消按钮，则方法返回false prompt() 显示可提示用户输入的对话框。 * 返回值：获取用户输入的值 2. 与打开关闭有关的方法： close() 关闭浏览器窗口。 * 谁调用我 ，我关谁 open() 打开一个新的浏览器窗口 * 返回新的Window对象 3. 与定时器有关的方式 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 * 参数： 1. js代码或者方法对象 2. 毫秒值 * 返回值：唯一标识，用于取消定时器 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。 3. 属性： 1. 获取其他BOM对象： history location Navigator Screen: 2. 获取DOM对象 document 4. 特点 * Window对象不需要创建可以直接使用 window使用。 window.方法名(); * window引用可以省略。 方法名(); 4. Location：地址栏对象 1. 创建(获取)： 1. window.location 2. location 2. 方法： * reload() 重新加载当前文档。刷新 3. 属性 * href 设置或返回完整的 URL。 5. History：历史记录对象 1. 创建(获取)： 1. window.history 2. history 2. 方法： * back() 加载 history 列表中的前一个 URL。 * forward() 加载 history 列表中的下一个 URL。 * go(参数) 加载 history 列表中的某个具体页面。 * 参数： * 正数：前进几个历史记录 * 负数：后退几个历史记录 3. 属性： * length 返回当前窗口历史列表中的 URL 数量。DOM：* 概念： Document Object Model 文档对象模型 * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作 * W3C DOM 标准被分为 3 个不同的部分： * 核心 DOM - 针对任何结构化文档的标准模型 * Document：文档对象 * Element：元素对象 * Attribute：属性对象 * Text：文本对象 * Comment:注释对象 * Node：节点对象，其他5个的父对象 * XML DOM - 针对 XML 文档的标准模型 * HTML DOM - 针对 HTML 文档的标准模型 * 核心DOM模型： * Document：文档对象 1. 创建(获取)：在html dom模型中可以使用window对象来获取 1. window.document 2. document 2. 方法： 1. 获取Element对象： 1. getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一 2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组 4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 2. 创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode() 3. 属性 * Element：元素对象 1. 获取/创建：通过document来获取和创建 2. 方法： 1. removeAttribute()：删除属性 2. setAttribute()：设置属性 * Node：节点对象，其他5个的父对象 * 特点：所有dom对象都可以被认为是一个节点 * 方法： * CRUD dom树： * appendChild()：向节点的子节点列表的结尾添加新的子节点。 * removeChild() ：删除（并返回）当前节点的指定子节点。 * replaceChild()：用新节点替换一个子节点。 * 属性： * parentNode 返回节点的父节点。 * HTML DOM 1. 标签体的设置和获取：innerHTML 2. 使用html元素对象的属性 3. 控制元素样式 1. 使用元素的style属性来设置 如： //修改样式方式1 div1.style.border = &quot;1px solid red&quot;; div1.style.width = &quot;200px&quot;; //font-size--&gt; fontSize div1.style.fontSize = &quot;20px&quot;; 2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。事件监听机制：* 概念：某些组件被执行了某些操作后，触发某些代码的执行。 * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 * 事件源：组件。如： 按钮 文本输入框... * 监听器：代码。 * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 * 常见的事件： 1. 点击事件： 1. onclick：单击事件 2. ondblclick：双击事件 2. 焦点事件 1. onblur：失去焦点 2. onfocus:元素获得焦点。 3. 加载事件： 1. onload：一张页面或一幅图像完成加载。 4. 鼠标事件： 1. onmousedown 鼠标按钮被按下。 2. onmouseup 鼠标按键被松开。 3. onmousemove 鼠标被移动。 4. onmouseover 鼠标移到某元素之上。 5. onmouseout 鼠标从某元素移开。​​ 5. 键盘事件：​ 1. onkeydown 某个键盘按键被按下。​ 2. onkeyup 某个键盘按键被松开。​ 3. onkeypress 某个键盘按键被按下并松开。​ 6. 选择和改变 1. onchange 域的内容被改变。 2. onselect 文本被选中。 7. 表单事件： 1. onsubmit 确认按钮被点击。 2. onreset 重置按钮被点击。","categories":[],"tags":[]},{"title":"","slug":"HTML&CSS课堂笔记","date":"2020-09-06T14:17:09.567Z","updated":"2020-09-06T08:34:10.668Z","comments":true,"path":"2020/09/06/HTML&CSS课堂笔记/","link":"","permalink":"https://zongyun1999.github.io/2020/09/06/HTML&CSS%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/","excerpt":"","text":"内容：1. HTML标签：表单标签 2. CSS：HTML标签：表单标签1234567891011121314151617* 表单： * 概念：用于采集用户输入的数据的。用于和服务器进行交互。 * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 * 属性： * action：指定提交数据的URL * method:指定提交方式 * 分类：一共7种，2种比较常用 * get： 1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。 2. 请求参数大小是有限制的。 3. 不太安全。 * post： 2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解) 2. 请求参数的大小没有限制。 3. 较为安全。 * 表单项中的数据要想被提交：必须指定其name属性 ​ 123456789101112131415161718192021222324252627282930313233* 表单项标签： * input：可以通过type属性值，改变元素展示的样式 * type属性： * text：文本输入框，默认值 * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 * password：密码输入框 * radio:单选框 * 注意： 1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。 2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值 3. checked属性，可以指定默认值 * checkbox：复选框 * 注意： 1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值 2. checked属性，可以指定默认值 * file：文件选择框 * hidden：隐藏域，用于提交一些信息。 * 按钮： * submit：提交按钮。可以提交表单 * button：普通按钮 * image：图片提交按钮 * src属性指定图片的路径 * label：指定输入项的文字描述信息 * 注意： * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 * select: 下拉列表 * 子元素：option，指定列表项 * textarea：文本域 * cols：指定列数，每一行有多少个字符 * rows：默认多少行。 CSS：页面美化和布局控制1234567891. 概念： Cascading Style Sheets 层叠样式表 * 层叠：多个样式可以作用在同一个html的元素上，同时生效2. 好处： 1. 功能强大 2. 将内容展示和样式控制分离 * 降低耦合度。解耦 * 让分工协作更容易 * 提高开发效率 12345678910111213141516171819202122232425262728293031323334353637383940414243443. CSS的使用：CSS与html结合方式 1. 内联样式 * 在标签内使用style属性指定css代码 * 如：&lt;div style=\"color:red;\"&gt;hello css&lt;/div&gt; 2. 内部样式 * 在head标签内，定义style标签，style标签的标签体内容就是css代码 * 如： &lt;style&gt; div&#123; color:blue; &#125; &lt;/style&gt; &lt;div&gt;hello css&lt;/div&gt; 3. 外部样式 1. 定义css资源文件。 2. 在head标签内，定义link标签，引入外部的资源文件 * 如： * a.css文件： div&#123; color:green; &#125; &lt;link rel=\"stylesheet\" href=\"css/a.css\"&gt; &lt;div&gt;hello css&lt;/div&gt; &lt;div&gt;hello css&lt;/div&gt; * 注意： * 1,2,3种方式 css作用范围越来越大 * 1方式不常用，后期常用2,3 * 3种格式可以写为： &lt;style&gt; @import \"css/a.css\"; &lt;/style&gt;4. css语法： * 格式： 选择器 &#123; 属性名1:属性值1; 属性名2:属性值2; ... &#125; * 选择器:筛选具有相似特征的元素 * 注意： * 每一对属性需要使用；隔开，最后一对属性可以不加； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555. 选择器：筛选具有相似特征的元素 * 分类： 1. 基础选择器 1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一 * 语法：#id属性值&#123;&#125; 2. 元素选择器：选择具有相同标签名称的元素 * 语法： 标签名称&#123;&#125; * 注意：id选择器优先级高于元素选择器 3. 类选择器：选择具有相同的class属性值的元素。 * 语法：.class属性值&#123;&#125; * 注意：类选择器选择器优先级高于元素选择器 2. 扩展选择器： 1. 选择所有元素： * 语法： *&#123;&#125; 2. 并集选择器： * 选择器1,选择器2&#123;&#125; 3. 子选择器：筛选选择器1元素下的选择器2元素 * 语法： 选择器1 选择器2&#123;&#125; 4. 父选择器：筛选选择器2的父元素选择器1 * 语法： 选择器1 &gt; 选择器2&#123;&#125; 5. 属性选择器：选择元素名称，属性名=属性值的元素 * 语法： 元素名称[属性名=\"属性值\"]&#123;&#125; 6. 伪类选择器：选择一些元素具有的状态 * 语法： 元素:状态&#123;&#125; * 如： &lt;a&gt; * 状态： * link：初始化的状态 * visited：被访问过的状态 * active：正在访问状态 * hover：鼠标悬浮状态6. 属性 1. 字体、文本 * font-size：字体大小 * color：文本颜色 * text-align：对其方式 * line-height：行高 2. 背景 * background： 3. 边框 * border：设置边框，符合属性 4. 尺寸 * width：宽度 * height：高度 5. 盒子模型：控制布局 * margin：外边距 * padding：内边距 * 默认情况下内边距会影响整个盒子的大小 * box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 * float：浮动 * left * right 案例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册页面&lt;/title&gt;&lt;style&gt; *&#123; margin: 0px; padding: 0px; box-sizing: border-box; &#125; body&#123; background: url(\"img/register_bg.png\") no-repeat center; padding-top: 25px; &#125; .rg_layout&#123; width: 900px; height: 500px; border: 8px solid #EEEEEE; background-color: white; /*让div水平居中*/ margin: auto; &#125; .rg_left&#123; /*border: 1px solid red;*/ float: left; margin: 15px; &#125; .rg_left &gt; p:first-child&#123; color:#FFD026; font-size: 20px; &#125; .rg_left &gt; p:last-child&#123; color:#A6A6A6; font-size: 20px; &#125; .rg_center&#123; float: left; /* border: 1px solid red;*/ &#125; .rg_right&#123; /*border: 1px solid red;*/ float: right; margin: 15px; &#125; .rg_right &gt; p:first-child&#123; font-size: 15px; &#125; .rg_right p a &#123; color:pink; &#125; .td_left&#123; width: 100px; text-align: right; height: 45px; &#125; .td_right&#123; padding-left: 50px ; &#125; #username,#password,#email,#name,#tel,#birthday,#checkcode&#123; width: 251px; height: 32px; border: 1px solid #A6A6A6 ; /*设置边框圆角*/ border-radius: 5px; padding-left: 10px; &#125; #checkcode&#123; width: 110px; &#125; #img_check&#123; height: 32px; vertical-align: middle; &#125; #btn_sub&#123; width: 150px; height: 40px; background-color: #FFD026; border: 1px solid #FFD026 ; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"rg_layout\"&gt; &lt;div class=\"rg_left\"&gt; &lt;p&gt;新用户注册&lt;/p&gt; &lt;p&gt;USER REGISTER&lt;/p&gt; &lt;/div&gt; &lt;div class=\"rg_center\"&gt; &lt;div class=\"rg_form\"&gt; &lt;!--定义表单 form--&gt; &lt;form action=\"#\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"username\"&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"请输入用户名\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"password\"&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"password\" name=\"password\" id=\"password\" placeholder=\"请输入密码\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"email\"&gt;Email&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"email\" name=\"email\" id=\"email\" placeholder=\"请输入邮箱\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"name\"&gt;姓名&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"name\" id=\"name\" placeholder=\"请输入姓名\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"tel\"&gt;手机号&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"tel\" id=\"tel\" placeholder=\"请输入手机号\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"male\"&gt; 男 &lt;input type=\"radio\" name=\"gender\" value=\"female\"&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"birthday\"&gt;出生日期&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"date\" name=\"birthday\" id=\"birthday\" placeholder=\"请输入出生日期\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"checkcode\" &gt;验证码&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"checkcode\" id=\"checkcode\" placeholder=\"请输入验证码\"&gt; &lt;img id=\"img_check\" src=\"img/verify_code.jpg\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" align=\"center\"&gt;&lt;input type=\"submit\" id=\"btn_sub\" value=\"注册\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"rg_right\"&gt; &lt;p&gt;已有账号?&lt;a href=\"#\"&gt;立即登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"","slug":"BootStrap笔记","date":"2020-09-06T14:17:09.565Z","updated":"2020-09-06T08:34:12.378Z","comments":true,"path":"2020/09/06/BootStrap笔记/","link":"","permalink":"https://zongyun1999.github.io/2020/09/06/BootStrap%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今日内容1. BootstrapBootstrap：1234561. 概念： 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。 * 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。 * 好处： 1. 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。 2. 响应式布局。 * 同一套页面可以兼容不同分辨率的设备。 12342. 快速入门 1. 下载Bootstrap 2. 在项目中将这三个文件夹复制 3. 创建html页面，引入必要的资源文件 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=\"js/jquery-3.2.1.min.js\"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; ​ 响应式布局12345678910111213141516171819* 同一套页面可以兼容不同分辨率的设备。* 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子* 步骤： 1. 定义容器。相当于之前的table、 * 容器分类： 1. container：两边留白 2. container-fluid：每一种设备都是100%宽度 2. 定义行。相当于之前的tr 样式：row 3. 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目 * 设备代号： 1. xs：超小屏幕 手机 (&lt;768px)：col-xs-12 2. sm：小屏幕 平板 (≥768px) 3. md：中等屏幕 桌面显示器 (≥992px) 4. lg：大屏幕 大桌面显示器 (≥1200px) * 注意： 1. 一行中如果格子数目超过12，则超出部分自动换行。 2. 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。 3. 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 CSS样式和JS插件1. 全局CSS样式： * 按钮：class=&quot;btn btn-default&quot; * 图片： * class=&quot;img-responsive&quot;：图片在任意尺寸都占100% * 图片形状 * &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;：方形 * &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; ： 圆形 * &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; ：相框 * 表格 * table * table-bordered * table-hover * 表单 * 给表单项添加：class=&quot;form-control&quot; 2. 组件： * 导航条 * 分页条 3. 插件： * 轮播图案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;​ &lt;script src=\"js/jquery-3.2.1.min.js\"&gt;&lt;/script&gt;​ &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;​ &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;​ &lt;style&gt;​ .paddtop&#123;​ padding-top: 10px;​ &#125;​ .search-btn&#123;​ float: left;​ border:1px solid #ffc900;​ width: 90px;​ height: 35px;​ background-color:#ffc900 ;​ text-align: center;​ line-height: 35px;​ margin-top: 15px;​ &#125;​ ​ .search-input&#123;​ float: left;​ border:2px solid #ffc900;​ width: 400px;​ height: 35px;​ padding-left: 5px;​ margin-top: 15px;​ &#125;​ .jx&#123;​ border-bottom: 2px solid #ffc900;​ padding: 5px;​ &#125;​ .company&#123;​ height: 40px;​ background-color: #ffc900;​ text-align: center;​ line-height:40px ;​ font-size: 8px;​ &#125;​ &lt;/style&gt;​ &lt;/head&gt;​ &lt;body&gt;​ ​ &lt;!-- 1.页眉部分--&gt;​ &lt;header class=\"container-fluid\"&gt;​ &lt;div class=\"row\"&gt;​ &lt;img src=\"img/top_banner.jpg\" class=\"img-responsive\"&gt;​ &lt;/div&gt;​ &lt;div class=\"row paddtop\"&gt;​ &lt;div class=\"col-md-3\"&gt;​ &lt;img src=\"img/logo.jpg\" class=\"img-responsive\"&gt;​ &lt;/div&gt;​ &lt;div class=\"col-md-5\"&gt;​ &lt;input class=\"search-input\" placeholder=\"请输入线路名称\"&gt;​ &lt;a class=\"search-btn\" href=\"#\"&gt;搜索&lt;/a&gt;​ &lt;/div&gt;​ &lt;div class=\"col-md-4\"&gt;​ &lt;img src=\"img/hotel_tel.png\" class=\"img-responsive\"&gt;​ &lt;/div&gt;​ &lt;/div&gt; &lt;!--导航栏--&gt; &lt;div class=\"row\"&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=\"navbar-header\"&gt; &lt;!-- 定义汉堡按钮 --&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\" aria-expanded=\"false\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;Link &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;!--轮播图--&gt; &lt;div class=\"row\"&gt; &lt;div id=\"carousel-example-generic\" class=\"carousel slide\" data-ride=\"carousel\"&gt; &lt;!-- Indicators --&gt; &lt;ol class=\"carousel-indicators\"&gt; &lt;li data-target=\"#carousel-example-generic\" data-slide-to=\"0\" class=\"active\"&gt;&lt;/li&gt; &lt;li data-target=\"#carousel-example-generic\" data-slide-to=\"1\"&gt;&lt;/li&gt; &lt;li data-target=\"#carousel-example-generic\" data-slide-to=\"2\"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=\"carousel-inner\" role=\"listbox\"&gt; &lt;div class=\"item active\"&gt; &lt;img src=\"img/banner_1.jpg\" alt=\"...\"&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img src=\"img/banner_2.jpg\" alt=\"...\"&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img src=\"img/banner_3.jpg\" alt=\"...\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class=\"left carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"prev\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-left\" aria-hidden=\"true\"&gt;&lt;/span&gt; &lt;span class=\"sr-only\"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=\"right carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"next\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-right\" aria-hidden=\"true\"&gt;&lt;/span&gt; &lt;span class=\"sr-only\"&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;​ ​ &lt;/header&gt;​ &lt;!-- 2.主体部分--&gt;​ &lt;div class=\"container\"&gt;​ &lt;div class=\"row jx\"&gt;​ &lt;img src=\"img/icon_5.jpg\"&gt;​ &lt;span&gt;黑马精选&lt;/span&gt;​ &lt;/div&gt;​ ​ &lt;div class=\"row paddtop\"&gt;​ &lt;div class=\"col-md-3\"&gt;​ &lt;div class=\"thumbnail\"&gt;​ &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt;​ &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;​ &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt;​ &lt;/div&gt;​ &lt;/div&gt;​ &lt;div class=\"col-md-3\"&gt;​ &lt;div class=\"thumbnail\"&gt;​ &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt;​ &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;​ &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt;​ &lt;/div&gt;​ &lt;/div&gt; &lt;div class=\"col-md-3\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-3\"&gt; &lt;img src=\"img/icon_6.jpg\"&gt; &lt;span&gt;国内游&lt;/span&gt; &lt;/div&gt; &lt;div class=\"row paddtop\"&gt; &lt;div class=\"col-md-4\"&gt; &lt;img src=\"img/guonei_1.jpg\"&gt; &lt;/div&gt; &lt;div class=\"col-md-8\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 3.页脚部分--&gt; &lt;footer class=\"container-fluid\"&gt; &lt;div class=\"row\"&gt; &lt;img src=\"img/footer_service.png\" class=\"img-responsive\"&gt; &lt;/div&gt; &lt;div class=\"row company\"&gt; 江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882 &lt;/div&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; ​ ​","categories":[],"tags":[]},{"title":"Java学习路线","slug":"Java学习路线","date":"2020-05-25T15:45:17.000Z","updated":"2020-05-25T15:46:04.429Z","comments":true,"path":"2020/05/25/Java学习路线/","link":"","permalink":"https://zongyun1999.github.io/2020/05/25/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"Java学习路线[TOC] JAVA基础 《Java核心技术卷》 《Effective Java》 《Java编程思想》 MySQL 《高性能MySQL》 《MySQL技术内幕：InnoDB存储引擎》 前端基础（html 、css、js、前端框架）常见框架（SSM、Spring Boot）项目实战JAVA并发编程 《Java并发编程》 《Java并发编程艺术》 《Java并发编程之美》 JVM 《深入理解Java虚拟机》 JDK源码开发工具MySQL进阶（原理、调优）Redis 《Redis深度历险：核心原理与技术》 《Redis设计与实现》 微服务中间件框架源码计算机基础","categories":[{"name":"学习","slug":"学习","permalink":"https://zongyun1999.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"https://zongyun1999.github.io/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"JAVA","slug":"JAVA","permalink":"https://zongyun1999.github.io/tags/JAVA/"}]},{"title":"Java反射基础(reflect)-1","slug":"Java反射基础-reflect-1","date":"2020-05-25T14:33:35.000Z","updated":"2021-03-11T13:30:23.867Z","comments":true,"path":"2020/05/25/Java反射基础-reflect-1/","link":"","permalink":"https://zongyun1999.github.io/2020/05/25/Java%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80-reflect-1/","excerpt":"","text":"反射（reflect）定义：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制 class类 在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。 类型标识跟踪每一个对象所属于的类，虚拟机利用运行时类型信息选择相应的方法执行。 可以通过专门的Java类访问这些信息，保存这些信息的类称为class类 获得class对象的3种方法 通过Object的.class方法 对象的getclass（） forName( string name) 此方法需要异常处理，只有在name代表的是一个接口或者一个类名时才可以 使用newInstance()创建一个类的实例，默认调用无参构造函数 Filed类 import java.lang.reflect.Constructor; import java.lang.reflect.Field; public class Filed_reflect { public static void main(String[] args) throws Exception { Class c=Class.forName(\"for_test_reflect\"); Field[] fields=c.getFields(); System.out.println(\"----------获取公有的成员变量-----------\"); for (Field a:fields){ System.out.println(a); } fields=c.getDeclaredFields(); System.out.println(\"----------获取所有的成员变量-----------\"); for (Field a:fields){ System.out.println(a); } Field s = c.getDeclaredField(\"age\"); System.out.println(s); Constructor cons=c.getConstructor(); Object obj = cons.newInstance(); s.set(obj,100); for_test_reflect ftr=(for_test_reflect)obj; ftr.show(); } } &lt;!--￼0--&gt; Constructor类 import jdk.nashorn.internal.ir.CatchNode; import java.lang.reflect.Constructor; public class Constructor_reflect { public static void main(String[] args) throws Exception { Class c=Class.forName(\"for_test_reflect\"); //获取所有的公有构造方法 Constructor[] constructors=c.getConstructors(); System.out.println(\"----------------获取所有的公有构造方法----------------------\"); for (Constructor a:constructors){ System.out.println(a); } constructors=c.getDeclaredConstructors(); System.out.println(\"----------------获取所有构造方法----------------------\"); for (Constructor a:constructors){ System.out.println(a); } //调用构造器 Constructor c1=c.getConstructor(null); c1.newInstance(); //调用私有构造方法 Constructor c2=c.getDeclaredConstructor(int.class); c2.setAccessible(true);//对于私有的构造函数的访问需要强制访问 c2.newInstance(30); } }","categories":[{"name":"学习","slug":"学习","permalink":"https://zongyun1999.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://zongyun1999.github.io/tags/JAVA/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://zongyun1999.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"https://zongyun1999.github.io/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"JAVA","slug":"JAVA","permalink":"https://zongyun1999.github.io/tags/JAVA/"}]}