<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="first java"><meta name="keywords" content="java,核心基础"><meta name="author" content="zongyun,2918225580@qq.com"><meta name="copyright" content="zongyun"><title>first java | zongyunのblog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA核心技术卷（基础）"><span class="toc-number">1.</span> <span class="toc-text">JAVA核心技术卷（基础）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一部分（基础知识）"><span class="toc-number">1.1.</span> <span class="toc-text">第一部分（基础知识）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内联和main"><span class="toc-number">1.1.1.</span> <span class="toc-text">内联和main()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">1.1.2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本运算"><span class="toc-number">1.1.3.</span> <span class="toc-text">基本运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算"><span class="toc-number">1.1.4.</span> <span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象和类"><span class="toc-number">1.2.</span> <span class="toc-text">对象和类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础知识"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类之间的关系"><span class="toc-number">1.2.2.</span> <span class="toc-text">类之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象和对象变量"><span class="toc-number">1.2.3.</span> <span class="toc-text">对象和对象变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态域和静态方法"><span class="toc-number">1.2.4.</span> <span class="toc-text">静态域和静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态工厂方法和工厂模式"><span class="toc-number">1.2.5.</span> <span class="toc-text">静态工厂方法和工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法参数"><span class="toc-number">1.2.6.</span> <span class="toc-text">方法参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Method类"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">Method类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口、lambda表达式与内部类"><span class="toc-number">1.3.</span> <span class="toc-text">接口、lambda表达式与内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">1.3.1.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定义接口"><span class="toc-number">1.3.1.0.1.</span> <span class="toc-text">定义接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda表达式"><span class="toc-number">1.3.2.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#optional"><span class="toc-number">1.3.3.</span> <span class="toc-text">optional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回调函数"><span class="toc-number">1.3.4.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-number">1.3.5.</span> <span class="toc-text">内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常、日志、断言和调试"><span class="toc-number">1.4.</span> <span class="toc-text">异常、日志、断言和调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常的结构"><span class="toc-number">1.4.1.</span> <span class="toc-text">异常的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建异常类"><span class="toc-number">1.4.2.</span> <span class="toc-text">创建异常类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#捕获异常"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">捕获异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型代码和虚拟机"><span class="toc-number">1.4.3.</span> <span class="toc-text">泛型代码和虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原始类型"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">原始类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#翻译泛型表达式"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">翻译泛型表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#桥方法"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">桥方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型几个重要的点："><span class="toc-number">1.4.3.4.</span> <span class="toc-text">泛型几个重要的点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型–通配符类型"><span class="toc-number">1.4.4.</span> <span class="toc-text">泛型–通配符类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通配符的子类型限定"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">通配符的子类型限定</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">zongyun</div><div class="author-info__description text-center">没看出我哪里变了吗</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">2</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2020/05/22/vmgxFV18Mr4Kcw5.jpg# false or url of img)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">zongyunのblog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">first java</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="JAVA核心技术卷（基础）"><a href="#JAVA核心技术卷（基础）" class="headerlink" title="JAVA核心技术卷（基础）"></a>JAVA核心技术卷（基础）</h1><p>[toc]</p>
<h2 id="第一部分（基础知识）"><a href="#第一部分（基础知识）" class="headerlink" title="第一部分（基础知识）"></a>第一部分（基础知识）</h2><h3 id="内联和main"><a href="#内联和main" class="headerlink" title="内联和main()"></a>内联和main()</h3><ul>
<li>内联是将引用简短的函数的地方采用插入整个函数体的方式进行替代，内联需要考虑的一个重要问题是 时空间的权衡;</li>
<li>java的每个方法都必须在类中，因此即使是main函数也有一个外壳类。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>Java有 4种整型 1种用以表示unicode编码的char 表示真假的boolean 2种浮点型 （java含有一个用来表示任意精度 的包 “big number”</li>
<li>无穷大 无穷小  NaN。对NaN的判断Java种认为任何非数的值都是不同。所以对于Java种NaN的判断不可以使用== 应该用Double.isNaN()</li>
<li>java采用’   ‘表示char。对于char类型，一般一个unicode编码用一个char类型进行表示，但是有些需要使用2个进行表示。</li>
<li>在Java中尽量少的使用char类型</li>
<li>boolean类型在Java中是false和true(java和c++区别 java中的不可以以数值进行表示)</li>
</ul>
<h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><ul>
<li><p>java中进行强制类型转换： （int）2.3433</p>
</li>
<li><p>字符串 对于字符串的判断相等 不要使用== 对于==是判断是否在同一个位置。当然在同一个位置的肯定相等，但是不在同一个位置，并不意味着不相等。</p>
</li>
<li><p>unicode码点和代码单元，一个码点一般由代码单元表示。Str.charAt(),返回代码单元。</p>
</li>
<li><p>空串和null串的判断</p>
<p> 对于空串  str.equal(“”)  str.length()==0</p>
<p> 对于null串  使用isNULL进行判断</p>
</li>
<li><p>右结合运算符：从最右边开始运算     右结合：new 、 ++ 、= ! 、+ 、- 、+=、 /=</p>
</li>
<li><p>多维数组的访问 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] s:temp) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> a:s) &#123;</span><br><span class="line">				System.out.println(a);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;temp[i].length;k++) &#123;</span><br><span class="line">				System.out.println(temp[i][k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>数组的快速打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.deeptoString（）</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;Arrays.copyOf(temp);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><ul>
<li><p>java中&amp;&amp;和&amp;分别用于逻辑运算和位运算</p>
</li>
<li><p>位运算技巧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span>==(a&amp;<span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>位运算交换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(a,b)</span> </span>&#123;</span><br><span class="line">	a^=b;</span><br><span class="line">	b^=a;</span><br><span class="line">	a^=b;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>位运算乘除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply_2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">division_2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>构造函数不止一个，构造函数没有返回值。Java的对象都是在堆中构造的。</li>
<li>静态域属于类而不属于对象</li>
<li>不需要使用对象调用静态方法，使用类名就可以调用静态方法。Main方法也是一个静态方法</li>
<li>一个方法不能让一个对象引用新对象</li>
<li>finalize方法类似于 c++的析构方法 </li>
<li>private public protected  默认 其中默认对于本类和本包可见  protected对于本类和本包以及其他包中的子类可见</li>
<li>为什么Import语句不仅可以导入类还可以导入静态方法和静态域？c++中的include和 java的import,因为java可以查看外部文件，而c++不可以</li>
<li>Java还支持静态导入  import static 可以导入一个类的静态域和静态方法，从而直接引用。</li>
<li>对于Java的包名尽量不同，sun公司建议采用域名倒置作为包名，保持唯一性。</li>
<li>只能使用”星号”导入一个包。不能import java.*</li>
</ul>
<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><ul>
<li>is-a (继承) </li>
<li>uses-a（依赖）</li>
<li>has-a（聚合）</li>
</ul>
<h3 id="对象和对象变量"><a href="#对象和对象变量" class="headerlink" title="对象和对象变量"></a>对象和对象变量</h3><p>对象变量和基本变量类似。</p>
<p>对象变量的赋值使用构造器也可以引用一个已经存在的对象</p>
<p>对象变量并没有包含一个对象，而只是引用一个对象</p>
<p>在Java中，任何对象变量存储的值都是对像的引用，即使new关键字返回的也是一个对象的引用</p>
<h3 id="静态域和静态方法"><a href="#静态域和静态方法" class="headerlink" title="静态域和静态方法"></a>静态域和静态方法</h3><ul>
<li>静态域和静态方法都属于类</li>
<li>静态变量由所有对象所共享</li>
<li>静态方法可以通过类名直接调用，也可以使用对象进行调用</li>
</ul>
<h3 id="静态工厂方法和工厂模式"><a href="#静态工厂方法和工厂模式" class="headerlink" title="静态工厂方法和工厂模式"></a>静态工厂方法和工厂模式</h3><p>形式：通过工厂对象的方法实现类的实例化</p>
<p>使用场景：</p>
<ul>
<li>类的实例化比较复杂</li>
<li>需要对外屏蔽类的实例化的参数情况</li>
</ul>
<h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><ul>
<li><p>基本数据类型作为参数的调用过程</p>
<ul>
<li><pre><code class="java"><span class="keyword">int</span> oldValue=<span class="number">9</span>;<span class="keyword">int</span> newValue=<span class="number">8</span>;
swap(old,<span class="keyword">new</span>)
&lt;!--￼<span class="number">6</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>实现一个相等的方法的过程：</p>
<ul>
<li><p>检测是否引用同一个对象</p>
</li>
<li><p>检测是否为null，是则返回false</p>
</li>
<li><p>检测是否属于同一个类，如果具有相同的相等的概念，使用instanceof ,如果不同的话采用getclass</p>
</li>
<li><p>进行类型转换，比较实例域</p>
</li>
<li><pre><code class="java">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equal</span><span class="params">(Object obj)</span></span>{
          <span class="keyword">if</span>(<span class="keyword">this</span>==obj)<span class="keyword">return</span> <span class="keyword">true</span>;
          <span class="keyword">if</span> (obj==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;
          <span class="keyword">if</span>(!(getClass()==obj.getClass()))<span class="keyword">return</span>  <span class="keyword">false</span>;<span class="comment">//他们具有不同的相等概念</span>
          <span class="keyword">if</span> (<span class="keyword">super</span>.equal(obj)==<span class="keyword">false</span>)<span class="keyword">return</span>  <span class="keyword">false</span>;
          student temp_student=(student)obj;
          <span class="keyword">return</span>  <span class="keyword">this</span>.stuNumber.equals(temp_student.stuNumber);
      }
&lt;!--￼<span class="number">7</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>toString方法</p>
<ul>
<li><p>只要和字符串使用一个+连接起来就可以，Java编译的时候就可以显示的调用toString（）</p>
</li>
<li><pre><code class="java">    <span class="meta">@Override</span>
      <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>{
          <span class="keyword">return</span> <span class="keyword">super</span>.toString()+<span class="string">"[stuNumber="</span>+stuNumber+<span class="string">"]"</span>;

      }
&lt;!--￼<span class="number">8</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h4><ul>
<li><pre><code class="java"><span class="keyword">import</span> java.lang.reflect.Constructor;
<span class="keyword">import</span> java.lang.reflect.Method;

<span class="comment">/**</span>
<span class="comment"> * <span class="doctag">@author</span> zy</span>
<span class="comment"> * <span class="doctag">@version</span> 1.8</span>
<span class="comment"> * <span class="doctag">@date</span> 2020/5/16 12:51</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method_reflect</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>{
        Class c=Class.forName(<span class="string">"for_test_reflect"</span>);
        Method[] methods=c.getDeclaredMethods();
        <span class="keyword">for</span> (Method a:methods){
            System.out.println(a);
        }

        Method m=c.getMethod(<span class="string">"doWhat"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;
        Constructor cs=c.getConstructor();
        Object obj = cs.newInstance();
        for_test_reflect temp=(for_test_reflect)obj;
        m.invoke(temp,<span class="string">"test---"</span>);
    }
}

&lt;!--￼<span class="number">9</span>--&gt;
</code></pre>
</li>
</ul>
<h2 id="接口、lambda表达式与内部类"><a href="#接口、lambda表达式与内部类" class="headerlink" title="接口、lambda表达式与内部类"></a>接口、lambda表达式与内部类</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>接口中的方法自动的属于public，所以不需要显示的指出；但是在实现接口时，必须显示定义为public</li>
<li>接口像需要具有功能的规范（要具有sort()排序的功能，要实现comparable的接口）</li>
<li>接口不能含有实例域，但是可以有常量；</li>
<li>可以用instanceof 检查一个对象是否实现了接口</li>
</ul>
<h5 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h5><ul>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">study_interface</span> </span>{
    <span class="function"><span class="keyword">void</span> <span class="title">doable</span><span class="params">()</span></span>;

}
&lt;!--￼<span class="number">10</span>--&gt;
</code></pre>
</li>
</ul>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><ul>
<li><p>定义：()-&gt;expression;     { ()-&gt;expression;}</p>
</li>
<li><p>个人理解：lambda类型是一个接口，而lambda本身那个代码块是一个接口的实现</p>
</li>
<li><p><strong>一个接口函数需要被实现的接口类型，我们叫它”函数式接口“</strong></p>
</li>
<li><p>lambda 表达式所做的也只是转化为函数式接口</p>
</li>
<li><p>lambda表达式的作用：</p>
<ul>
<li><p>使得代码清晰简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">comparator_study</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">people</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(people o1, people o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o1.getAge()&gt;o2.getAge())<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o1.getAge()&lt;o2.getAge()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	   Comparator com=<span class="keyword">new</span> comparator_study();</span><br><span class="line">	   Arrays.sort(a,com);<span class="comment">//实现一个比较需要先用一个类实现一个接口，在让接口变量引用一个类的实例</span></span><br><span class="line"><span class="comment">//再将这个接口变量作为方法的参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于lambda表达式</span></span><br><span class="line">Arrays.sort(a,(first,second)-&gt;first.getAge()-second.getAge());<span class="comment">//一条语句完成上述全部</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li>lambda表达式配合新特性更好用</li>
</ul>
<h3 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h3><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><ul>
<li>在一个函数调用时，向它传入不同的函数，从而产生不同的操作</li>
<li>优势：回调函数能极大的增加函数的灵活性</li>
<li>回调函数涉及的3个函数 中间函数 回调函数 起始函数</li>
<li>过程：起始函数控制中间函数登记哪个回调函数</li>
<li>阻塞式回调和延迟回调</li>
<li>理解：类比sort的2种排序的接口</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul>
<li><p>使用内部类的原因：</p>
<ol>
<li>内部类帮助构建外部类（参考数据结构栈和队列等的实现）</li>
</ol>
</li>
<li><p>内部类有一个隐式的引用指向外围类的对象（实现：编译器修改内部类的构造函数，为它添加一个外围类的引用）</p>
</li>
<li><p>内部类是一种编译器现象，对于虚拟机屏蔽</p>
</li>
<li><p>静态内部类只能访问静态域，因为静态内部类不依托于类的实例化，所以只能访问static</p>
</li>
<li><p>必须先有外部类的实例对象，才能生成内部类的对象，因为内部类需要访问外部类的域</p>
</li>
<li><p>为什么内部类能够访问外部类的所有？</p>
<ul>
<li><strong>内部类有一个隐式的引用指向外围类的对象（实现：编译器修改内部类的构造函数，为它添加一个外围类的引用）</strong></li>
</ul>
</li>
<li><p>为什么局部内部类的访问变量都需要是final？</p>
<ul>
<li>对于局部内部类访问局部变量时，可能局部变量已经消失，所以对于已经定义的局部变量直接拷贝到内部，而未得到值的采用构造函数的传递，传入内部类，就可能造成内部类中的参数和外部参数不一致，所以使用final</li>
</ul>
</li>
<li><p>3种内部类的实例化方式</p>
<ul>
<li><strong>静态内部类：外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</strong></li>
<li>成员内部类：<strong>外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</strong></li>
</ul>
</li>
<li><p>内部类的使用场景：</p>
</li>
<li><p>使用内部类代替接口对象（使用lambda表达式代替函数式接口）</p>
</li>
<li><p><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></p>
</li>
</ul>
<h2 id="异常、日志、断言和调试"><a href="#异常、日志、断言和调试" class="headerlink" title="异常、日志、断言和调试"></a>异常、日志、断言和调试</h2><p>java语言的3种错误处理机制</p>
<p>异常处理 、断言、日志</p>
<h3 id="异常的结构"><a href="#异常的结构" class="headerlink" title="异常的结构"></a>异常的结构</h3><ul>
<li><img src="C:\Users\zongyun\AppData\Roaming\Typora\typora-user-images\image-20200518215256990.png" alt="image-20200518215256990" style="zoom:50%;" />
</li>
<li><p>Error类的层次结构描述了Java运行系统的内部错误和资源耗尽错误</p>
</li>
<li><p>Runtime Exception包括数组越界 、空指针、错误的类型转换</p>
</li>
<li><p><code>如果出现Runtime Exception异常，那一定是你的问题</code>0.0</p>
</li>
<li><p>Java将派生于Error 和Runtime exception 的异常都 unchecked异常,其余的是checked异常</p>
</li>
<li><p>对于uncheced的异常要么不可控制，要么可以避免发生</p>
</li>
</ul>
<h3 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h3><ul>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Custom_exception</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>{
    <span class="function"><span class="keyword">public</span> <span class="title">Custom_exception</span><span class="params">()</span></span>{}
    <span class="function"><span class="keyword">public</span> <span class="title">Custom_exception</span><span class="params">(String msg)</span></span>{
        <span class="keyword">super</span>(msg);
        Scanner in = <span class="keyword">new</span> Scanner(System.in);
        String temp=in.next();
        System.out.println(temp);
    }
}

&lt;!--￼<span class="number">12</span>--&gt;
</code></pre>
</li>
</ul>
<h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><ul>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">study_catchException</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Custom_exception </span>{
  <span class="keyword">try</span> {
      <span class="keyword">int</span> a=<span class="number">10</span>/<span class="number">0</span>;
  }<span class="keyword">catch</span> (ArithmeticException e){
      System.out.println(e.fillInStackTrace());
      System.out.println(<span class="string">"catch"</span>);
  }
  <span class="keyword">finally</span>{
      System.out.println(<span class="string">"结束"</span>);
  }
    }
}
&lt;!--￼<span class="number">13</span>--&gt;</code></pre>
</li>
<li><p>对类型变量加以约束</p>
<ul>
<li><p>在类型变量的声明中进行限定 可以绑定接口也可以绑定类</p>
</li>
<li><p>还可以有多个约束，用”&amp;”进行连接</p>
</li>
<li><pre><code class="java"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">getMin</span><span class="params">(T first,T second)</span></span>{}

 <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends people&gt; <span class="function"><span class="keyword">void</span> <span class="title">testClass</span><span class="params">(T a)</span></span>{
        System.out.println(a.getClass().getName());

    }  
<span class="comment">//类型变量可以有多个限制</span>
    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends people &amp;Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">testClass</span><span class="params">(T a)</span></span>{
        System.out.println(a.getClass().getName());

    }</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h3><h4 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h4><ul>
<li>对于任何定义的泛型都提供一个原始类型</li>
<li>原始类型中擦除类型名，未做约束的类型变量替换为Object</li>
<li>有限定的类型变量的原始类型</li>
<li><img src="C:%5CUsers%5Czongyun%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200521141530874.png" alt="image-20200521141530874"></li>
<li><img src="C:%5CUsers%5Czongyun%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200521141547193.png" alt="image-20200521141547193"></li>
<li><img src="C:\Users\zongyun\AppData\Roaming\Typora\typora-user-images\image-20200521141629028.png" alt="image-20200521141629028" style="zoom:80%;" /></li>
<li>限定的顺序影响原始类型，所以将标签接口放在边界列表的末尾</li>
</ul>
<h4 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h4><ul>
<li>对于泛型存取和返回的类型带有强制转换</li>
</ul>
<h4 id="桥方法"><a href="#桥方法" class="headerlink" title="桥方法"></a>桥方法</h4><ul>
<li>泛型类型擦除时，会导致多态和泛型擦除的冲突，所以使用桥方法</li>
<li><strong>每个对象在定义时被分配一个类型。对于一个程序或者程序的一部分，如果使用的对象符合它们规定的类型，那么它们是类型安全的</strong></li>
<li></li>
</ul>
<h4 id="泛型几个重要的点："><a href="#泛型几个重要的点：" class="headerlink" title="泛型几个重要的点："></a>泛型几个重要的点：</h4><ol>
<li><code>在jvm中都是普通类</code></li>
<li><code>会将泛型使用替换为原始类型（无限制替换为Object 有限制替换为限制类型）</code></li>
<li><code>使用强制类型转换保证类型安全</code></li>
<li><code>桥方法被用来保持多态</code></li>
</ol>
<ul>
<li>不能使用基本变量类型实例化类型变量</li>
<li>不能对泛型进行运行时检查 instanceof  getClass</li>
<li>不能使用参数化类型实例化数组pair<String> [] a=new  pair<String> [] 如果需要存储参数化的类型可以使用ArrayList</li>
<li>不能实例化类型变量（这不是很显然吗？0.0）</li>
<li>静态域和方法不能使用类声明的类型变量，应该自己声明</li>
</ul>
<h3 id="泛型–通配符类型"><a href="#泛型–通配符类型" class="headerlink" title="泛型–通配符类型"></a>泛型–通配符类型</h3><h4 id="通配符的子类型限定"><a href="#通配符的子类型限定" class="headerlink" title="通配符的子类型限定"></a>通配符的子类型限定</h4><? extends E>  :E及其子类

- <img src="C:\Users\zongyun\AppData\Roaming\Typora\typora-user-images\image-20200521160144414.png" alt="image-20200521160144414" style="zoom:50%;" />

#### 通配符的超类型限定

- <? extends E>  :E及其超类

- <? super Manager>和子类型限定通配符不同，可以set()而不能get 因为可以直接Manager和其子类
- 带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。

#### 无限定的通配符

- <?>









<p>​        </p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:2918225580@qq.com">zongyun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/22/JAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71/">http://yoursite.com/2020/05/22/JAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/">核心基础</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2020/05/21/hello-world/"><span>Hello World</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2020/05/22/vmgxFV18Mr4Kcw5.jpg# false or url of img)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By zongyun</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>